### 闭包

**作用**：   
在JavaScript中，没有办法在函数外部访问到函数内部的变量对象。那么反之，有了闭包，我们可以在函数以外的任何地方访问到函数内部的变量对象。
**理解**：   
当函数a嵌套函数b时，通过闭包，将函数a中变量通过函数b暴露出去，从而使函数a的外部可以访问函数a的内部变量。就是两个函数彼此嵌套，内部函数就是闭包，形成闭包条件是内部函数需要通过return给返回出来。   
**特点**：    
有权利调用其上级环境的变量信息，作用域链。
**解决的问题**：    
重用一个对象，又保护对象不被污染篡改。     
**副作用**：     
违背垃圾机制， ie下会造成内存泄漏。 **如何解决**：解决闭包造成的内存泄漏: 手动删除，置为null;

```javascript
    function fn1() {
      var a = 1,
          b = 2;
      return function() {
           return a
      }    
	}

	var fn2 = fn1();
	fn2();    // 1
```
**分析**：这里fn1执行完成后，按理说，内部的a、b所在的作用域应该会销毁，但是因为闭包的存在，返回的匿名函数保留了对当前作用域的引用，因此我们可以在fn1执行完成之后，依然可以访问到fn1内部的变量a，这就是闭包的使用。（注意，这里虽然只是return了a，但是变量b也在内存中，也没有销毁，因为闭包保存的不是某个变量，而是整个变量对象）。这样在执行完fn2 = fn1()后，变量 fn2 实际上是指向了内部嵌套函数，再执行 fn2() 后就会得到返回值。这段代码其实就创建了一个闭包，为什么？因为函数 fn1 外的变量 fn2 引用了函数 fn1 内的嵌套函数，就是说：当函数 fn1 的内部函数被函数 fn1 外的一个变量 fn2引用的时候，就创建了一个闭包。

**一道经典的面试题：**  
```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
     console.log(i)  
  }, i * 1000) 
}
// 每隔1秒打印一个5， 定时器是异步的
```
**分析：**  
分析：setTimeout本身就是一个闭包；此时我们期待，每一次for循环，都能保存一个 i 的副本，但实际上，i 被定义在全局作用域，即只有一个 i ,每一个定时器指向的都是同一个 i ；

**实现每隔一秒一次打印数字：**
```javascript
// 方法一：
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
     console.log(i)  
  }, i * 1000) 
}
// let声明的变量有块级作用域，因此i有了5个副本，并且毫不相关
// 当我用let替换var的时候，既然每次循环都是一个块级作用域，互相不干扰，那为什么i会一直自动加1呢？因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

// 方法二：
for (var i = 0; i < 5; i++) {
  (function(j) {
      setTimeout(function() {
         console.log(j)  
      }, j * 1000) 
  })(i)
}　

// 深入理解：
function outer(){
  var i=1;
  return function(){
  console.log(i++);
}
}
vat getNum=outer();
getNum();//1
getNum();//2   // 同一作用域
i=1;
getNum();//3
getNum();//4

```


